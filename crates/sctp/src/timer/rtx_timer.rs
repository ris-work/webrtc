use async_trait::async_trait;
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tokio::time::Duration;

const RTO_INITIAL: u64 = 3000; // msec
const RTO_MIN: u64 = 1000; // msec
const RTO_MAX: u64 = 60000; // msec
const RTO_ALPHA: u64 = 1;
const RTO_BETA: u64 = 2;
const RTO_BASE: u64 = 8;
const MAX_INIT_RETRANS: usize = 8;
const PATH_MAX_RETRANS: usize = 5;
const NO_MAX_RETRANS: usize = 0;

/// rtoManager manages Rtx timeout values.
/// This is an implementation of RFC 4960 sec 6.3.1.
#[derive(Default, Debug)]
pub(crate) struct RtoManager {
    srtt: u64,
    rttvar: u64,
    rto: u64,
    no_update: bool,
    //mutex    sync.RWMutex
}

impl RtoManager {
    /// newRTOManager creates a new rtoManager.
    pub(crate) fn new() -> Self {
        RtoManager {
            rto: RTO_INITIAL,
            ..Default::default()
        }
    }

    /// set_new_rtt takes a newly measured RTT then adjust the RTO in msec.
    pub(crate) fn set_new_rtt(&mut self, rtt: u64) -> u64 {
        if self.no_update {
            return self.srtt;
        }

        if self.srtt == 0 {
            // First measurement
            self.srtt = rtt;
            self.rttvar = rtt / 2;
        } else {
            // Subsequent rtt measurement
            self.rttvar = ((RTO_BASE - RTO_BETA) * self.rttvar
                + RTO_BETA * (self.srtt as i64 - rtt as i64).abs() as u64)
                / RTO_BASE;
            self.srtt = ((RTO_BASE - RTO_ALPHA) * self.srtt + RTO_ALPHA * rtt) / RTO_BASE;
        }

        self.rto = std::cmp::min(std::cmp::max(self.srtt + 4 * self.rttvar, RTO_MIN), RTO_MAX);

        self.srtt
    }

    /// get_rto simply returns the current RTO in msec.
    pub(crate) fn get_rto(&self) -> u64 {
        self.rto
    }

    /// reset resets the RTO variables to the initial values.
    pub(crate) fn reset(&mut self) {
        if self.no_update {
            return;
        }

        self.srtt = 0;
        self.rttvar = 0;
        self.rto = RTO_INITIAL;
    }

    /// set RTO value for testing
    pub(crate) fn set_rto(&mut self, rto: u64, no_update: bool) {
        self.rto = rto;
        self.no_update = no_update;
    }
}

fn calculate_next_timeout(rto: u64, n_rtos: usize) -> u64 {
    // RFC 4096 sec 6.3.3.  Handle T3-rtx Expiration
    //   E2)  For the destination address for which the timer expires, set RTO
    //        <- RTO * 2 ("back off the timer").  The maximum value discussed
    //        in rule C7 above (RTO.max) may be used to provide an upper bound
    //        to this doubling operation.
    if n_rtos < 31 {
        std::cmp::min(rto << n_rtos, RTO_MAX)
    } else {
        RTO_MAX
    }
}

/// rtxTimerObserver is the inteface to a timer observer.
/// NOTE: Observers MUST NOT call start() or stop() method on rtxTimer
/// from within these callbacks.
#[async_trait]
pub(crate) trait RtxTimerObserver {
    async fn on_retransmission_timeout(&mut self, timer_id: usize, n: usize);
    async fn on_retransmission_failure(&mut self, timer_id: usize);
}

/// rtxTimer provides the retnransmission timer conforms with RFC 4960 Sec 6.3.1
#[derive(Default)]
pub(crate) struct RtxTimer {
    id: usize,
    max_retrans: usize,
    close_tx: Option<mpsc::Sender<()>>,
}

impl RtxTimer {
    /// newRTXTimer creates a new retransmission timer.
    /// if max_retrans is set to 0, it will keep retransmitting until stop() is called.
    /// (it will never make on_retransmission_failure() callback.
    pub(crate) fn new(id: usize, max_retrans: usize) -> Self {
        RtxTimer {
            id,
            max_retrans,
            close_tx: None,
        }
    }

    /// start starts the timer.
    pub(crate) fn start<T: 'static + RtxTimerObserver + std::marker::Send>(
        &mut self,
        timeout_observer: Arc<Mutex<T>>,
        rto: u64,
    ) -> bool {
        // this timer is already closed
        if self.close_tx.is_some() {
            return false;
        }

        // Note: rto value is intentionally not capped by RTO.Min to allow
        // fast timeout for the tests. Non-test code should pass in the
        // rto generated by rtoManager get_rto() method which caps the
        // value at RTO.Min or at RTO.Max.

        let (close_tx, mut close_rx) = mpsc::channel(1);
        let id = self.id;
        let max_retrans = self.max_retrans;
        tokio::spawn(async move {
            let mut n_rtos = 0;

            loop {
                let interval = calculate_next_timeout(rto, n_rtos);
                let timer = tokio::time::sleep(Duration::from_millis(interval));
                tokio::pin!(timer);

                tokio::select! {
                    _ = timer.as_mut() => {
                        n_rtos+=1;

                        let mut observer = timeout_observer.lock().await;
                        if max_retrans == 0 || n_rtos <= max_retrans {
                            observer.on_retransmission_timeout(id, n_rtos).await;
                        } else {
                            observer.on_retransmission_failure(id).await;
                            break;
                        }
                    }
                    _ = close_rx.recv() => break,
                }
            }
        });

        self.close_tx = Some(close_tx);
        true
    }

    /// stop stops the timer.
    pub fn stop(&mut self) {
        self.close_tx.take();
    }

    /// isRunning tests if the timer is running.
    /// Debug purpose only
    pub fn is_running(&self) -> bool {
        self.close_tx.is_some()
    }
}
